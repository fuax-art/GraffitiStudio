<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graffiti Art Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom CSS for color wheel and other elements */
        .color-wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: conic-gradient(
                red, yellow, lime, cyan, blue, magenta, red
            );
            position: relative;
            cursor: crosshair;
        }
        
        .color-preview {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        .color-theory-box {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
            cursor: pointer;
        }
        
        .brush-preview {
            width: 100%;
            height: 40px;
            border: 1px solid #ccc;
            background-color: white;
        }
        
        canvas {
            touch-action: none;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
        }
        
        .symmetry-line {
            position: absolute;
            background-color: rgba(255,0,0,0.3);
            width: 1px;
            height: 100%;
            top: 0;
            left: 50%;
            transform-origin: center;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Animation for spray can */
        @keyframes spray {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        .spray-animation {
            animation: spray 0.5s infinite;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto px-4 py-6">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-gray-800 flex items-center">
                <i class="fas fa-spray-can text-blue-500 mr-2 spray-animation"></i>
                Graffiti Art Studio
            </h1>
            <p class="text-gray-600">Create stunning street art with our digital tools</p>
        </header>
        
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left sidebar - Tools -->
            <div class="w-full lg:w-64 bg-white rounded-lg shadow p-4">
                <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                    <i class="fas fa-tools mr-2"></i>Tools
                </h2>
                
                <!-- Brush selection -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <i class="fas fa-paint-brush mr-2"></i>Brush Type
                    </h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button id="brush-standard" class="tool-btn active p-2 rounded border hover:bg-gray-100" title="Standard Brush">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button id="brush-calligraphy" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Calligraphy">
                            <i class="fas fa-pen-nib"></i>
                        </button>
                        <button id="brush-spray" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Spray Paint">
                            <i class="fas fa-spray-can"></i>
                        </button>
                        <button id="brush-marker" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Marker">
                            <i class="fas fa-highlighter"></i>
                        </button>
                        <button id="brush-eraser" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Eraser">
                            <i class="fas fa-eraser"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Brush size -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <i class="fas fa-arrows-alt-h mr-2"></i>Brush Size
                    </h3>
                    <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full">
                    <div class="text-center mt-1 text-sm text-gray-600">
                        Size: <span id="brush-size-value">5</span>px
                    </div>
                </div>
                
                <!-- Brush opacity -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <i class="fas fa-adjust mr-2"></i>Opacity
                    </h3>
                    <input type="range" id="brush-opacity" min="0.1" max="1" step="0.1" value="1" class="w-full">
                    <div class="text-center mt-1 text-sm text-gray-600">
                        Opacity: <span id="brush-opacity-value">100</span>%
                    </div>
                </div>
                
                <!-- Brush preview -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2">Preview</h3>
                    <div class="brush-preview flex items-center justify-center">
                        <div id="brush-preview-line" class="h-1 bg-black rounded-full"></div>
                    </div>
                </div>
                
                <!-- Clear canvas -->
                <button id="clear-canvas" class="w-full bg-red-500 hover:bg-red-600 text-white py-2 rounded flex items-center justify-center">
                    <i class="fas fa-trash mr-2"></i> Clear Canvas
                </button>
            </div>
            
            <!-- Main canvas area -->
            <div class="flex-1">
                <div class="bg-white rounded-lg shadow p-4">
                    <!-- Canvas controls -->
                    <div class="flex flex-wrap justify-between items-center mb-4">
                        <div class="flex space-x-2 mb-2 sm:mb-0">
                            <button id="toggle-trace-layer" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded flex items-center">
                                <i class="fas fa-layer-group mr-1"></i> Trace Layer
                            </button>
                            <button id="toggle-mandala" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded flex items-center">
                                <i class="fas fa-snowflake mr-1"></i> Mandala Mode
                            </button>
                        </div>
                        
                        <div class="flex space-x-2">
                            <button id="undo" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded flex items-center" title="Undo">
                                <i class="fas fa-undo mr-1"></i>
                            </button>
                            <button id="redo" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded flex items-center" title="Redo">
                                <i class="fas fa-redo mr-1"></i>
                            </button>
                            <button id="save-image" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded flex items-center">
                                <i class="fas fa-download mr-1"></i> Save
                            </button>
                        </div>
                    </div>
                    
                    <!-- Canvas container -->
                    <div class="relative border-2 border-gray-200 rounded overflow-hidden">
                        <canvas id="main-canvas" width="800" height="600"></canvas>
                        <canvas id="trace-canvas" width="800" height="600" class="absolute top-0 left-0 pointer-events-none opacity-50" style="display: none;"></canvas>
                        <div id="symmetry-lines" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="display: none;"></div>
                    </div>
                    
                    <!-- Background selection -->
                    <div class="mt-4">
                        <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                            <i class="fas fa-image mr-2"></i>Background
                        </h3>
                        <div class="flex flex-wrap gap-2">
                            <button data-bg="white" class="w-10 h-10 rounded border-2 border-gray-300 bg-white"></button>
                            <button data-bg="black" class="w-10 h-10 rounded border-2 border-gray-300 bg-black"></button>
                            <button data-bg="brick" class="w-10 h-10 rounded border-2 border-gray-300 bg-gray-300 flex items-center justify-center">
                                <i class="fas fa-bricks text-gray-600"></i>
                            </button>
                            <button data-bg="concrete" class="w-10 h-10 rounded border-2 border-gray-300 bg-gray-400 flex items-center justify-center">
                                <i class="fas fa-road text-gray-700"></i>
                            </button>
                            <button data-bg="wood" class="w-10 h-10 rounded border-2 border-gray-300 bg-amber-700 flex items-center justify-center">
                                <i class="fas fa-tree text-amber-900"></i>
                            </button>
                            <button id="custom-bg" class="w-10 h-10 rounded border-2 border-gray-300 bg-gray-100 flex items-center justify-center">
                                <i class="fas fa-upload text-gray-600"></i>
                            </button>
                            <input type="file" id="bg-upload" class="hidden" accept="image/*">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right sidebar - Color and letters -->
            <div class="w-full lg:w-64 bg-white rounded-lg shadow p-4">
                <!-- Color selection -->
                <div class="mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                        <i class="fas fa-palette mr-2"></i>Color
                    </h2>
                    
                    <!-- Current color preview -->
                    <div class="flex justify-center mb-4">
                        <div id="current-color" class="color-preview" style="background-color: #000000;"></div>
                    </div>
                    
                    <!-- Color wheel -->
                    <div class="flex justify-center mb-4">
                        <div class="color-wheel" id="color-wheel">
                            <div class="w-3 h-3 bg-white rounded-full absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none"></div>
                        </div>
                    </div>
                    
                    <!-- Recent colors -->
                    <div class="mb-4">
                        <h3 class="font-medium text-gray-700 mb-2">Recent Colors</h3>
                        <div id="recent-palette" class="flex space-x-2"></div>
                    </div>
                    
                    <!-- Color picker -->
                    <div class="mb-4">
                        <label for="color-hex" class="block text-sm font-medium text-gray-700 mb-1">Hex:</label>
                        <div class="flex">
                            <input type="text" id="color-hex" value="#000000" class="flex-1 border rounded-l px-2 py-1">
                            <button id="apply-hex" class="bg-blue-500 text-white px-2 py-1 rounded-r">
                                <i class="fas fa-check"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Monochromatic toggle -->
                    <div class="flex items-center mb-4">
                        <input type="checkbox" id="monochromatic-toggle" class="mr-2">
                        <label for="monochromatic-toggle" class="text-sm text-gray-700">Monochromatic</label>
                    </div>
                    
                    <!-- Color theory -->
                    <div class="mb-6">
                        <h3 class="font-medium text-gray-700 mb-2">Color Theory</h3>
                        <div class="grid grid-cols-4 gap-2">
                            <div>
                                <div id="complementary" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Complement</p>
                            </div>
                            <div>
                                <div id="triadic1" class="color-theory-box mx-auto mb-1"></div>
                                <div id="triadic2" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Triadic</p>
                            </div>
                            <div>
                                <div id="analogous1" class="color-theory-box mx-auto mb-1"></div>
                                <div id="analogous2" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Analogous</p>
                            </div>
                            <div>
                                <div id="tetradic1" class="color-theory-box mx-auto mb-1"></div>
                                <div id="tetradic2" class="color-theory-box mx-auto mb-1"></div>
                                <div id="tetradic3" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Tetradic</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Mandala settings (hidden by default) -->
                <div id="mandala-settings" class="mb-6" style="display: none;">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                        <i class="fas fa-snowflake mr-2"></i>Mandala
                    </h2>
                    
                    <div class="mb-4">
                        <label for="symmetry-points" class="block text-sm font-medium text-gray-700 mb-1">Symmetry Points:</label>
                        <input type="range" id="symmetry-points" min="2" max="99" value="6" class="w-full">
                        <div class="text-center mt-1 text-sm text-gray-600">
                            Points: <span id="symmetry-points-value">6</span>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Color Mode:</label>
                        <div class="flex space-x-2">
                            <button id="mandala-solid" class="flex-1 bg-blue-500 text-white py-1 px-2 rounded text-sm">Solid</button>
                            <button id="mandala-gradient" class="flex-1 bg-gray-200 text-gray-800 py-1 px-2 rounded text-sm">Gradient</button>
                        </div>
                    </div>
                    
                    <div id="gradient-colors" class="space-y-2" style="display: none;">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Gradient Colors:</label>
                        <div class="flex space-x-2">
                            <input type="color" id="gradient-start" value="#ff0000" class="w-8 h-8">
                            <input type="color" id="gradient-end" value="#0000ff" class="w-8 h-8">
                        </div>
                    </div>
                </div>
                
                <!-- Traceable letters -->
                <div id="letters-section">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                        <i class="fas fa-font mr-2"></i>Traceable Letters
                    </h2>
                    
                    <div class="mb-4">
                        <label for="letter-style" class="block text-sm font-medium text-gray-700 mb-1">Style:</label>
                        <select id="letter-style" class="w-full border rounded px-2 py-1">
                            <option value="block">Block</option>
                            <option value="bubble">Bubble</option>
                            <option value="wildstyle">Wildstyle</option>
                            <option value="tag">Tag</option>
                        </select>
                    </div>
                    
                    <div class="mb-4">
                        <label for="letter-case" class="block text-sm font-medium text-gray-700 mb-1">Case:</label>
                        <div class="flex space-x-2">
                            <button id="upper-case" class="flex-1 bg-blue-500 text-white py-1 px-2 rounded text-sm">Uppercase</button>
                            <button id="lower-case" class="flex-1 bg-gray-200 text-gray-800 py-1 px-2 rounded text-sm">Lowercase</button>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-6 gap-2" id="letters-grid">
                        <!-- Letters will be added here by JavaScript -->
                    </div>
                    
                    <div class="mt-4">
                        <button id="clear-letters" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded flex items-center justify-center">
                            <i class="fas fa-trash-alt mr-2"></i> Clear Letters
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Color theory explanation modal -->
        <div id="color-theory-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold" id="color-theory-title">Color Theory</h3>
                    <button id="close-color-modal" class="text-gray-500 hover:text-gray-700">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="color-theory-content">
                    <!-- Content will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Canvas setup
            const mainCanvas = document.getElementById('main-canvas');
            const traceCanvas = document.getElementById('trace-canvas');
            const mainCtx = mainCanvas.getContext('2d');
            const traceCtx = traceCanvas.getContext('2d');

            // State variables
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            let currentColor = '#000000';
            let currentBrush = 'standard';
            let brushSize = 5;
            let brushOpacity = 1;
            let isMonochromatic = false;
            let isMandalaMode = false;
            let mandalaSymmetryPoints = 6;
            let mandalaColorMode = 'solid';
            let gradientStart = '#ff0000';
            let gradientEnd = '#0000ff';
            let isTraceLayerVisible = false;
            let currentLetterCase = 'upper';
            let currentLetterStyle = 'block';
            let baseHsl = { h: 0, s: 100, l: 50 };
            let recentColors = [];

            // Undo/redo functionality
            let undoStack = [];
            let redoStack = [];
            const MAX_UNDO_STEPS = 20;

            // Initialize canvas
            function initCanvas() {
                mainCanvas.width = mainCanvas.offsetWidth;
                mainCanvas.height = mainCanvas.offsetHeight;
                traceCanvas.width = traceCanvas.offsetWidth;
                traceCanvas.height = traceCanvas.offsetHeight;

                // White background by default
                mainCtx.fillStyle = 'white';
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

                saveCanvasState();
                setupEventListeners();
                initColorWheel();
                initLetters();
                updateBrushPreview();
                updateColorTheory(currentColor);
                updatePaletteDisplay();
            }

            function setupEventListeners() {
                // Drawing events
                mainCanvas.addEventListener('mousedown', startDrawing);
                mainCanvas.addEventListener('mousemove', draw);
                mainCanvas.addEventListener('mouseup', stopDrawing);
                mainCanvas.addEventListener('mouseout', stopDrawing);

                // Touch events for mobile
                mainCanvas.addEventListener('touchstart', handleTouchStart);
                mainCanvas.addEventListener('touchmove', handleTouchMove);
                mainCanvas.addEventListener('touchend', handleTouchEnd);

                // Brush tools
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        currentBrush = this.id.replace('brush-', '');
                        updateBrushPreview();
                    });
                });

                // Brush size
                document.getElementById('brush-size').addEventListener('input', function() {
                    brushSize = parseInt(this.value);
                    document.getElementById('brush-size-value').textContent = brushSize;
                    updateBrushPreview();
                });

                // Brush opacity
                document.getElementById('brush-opacity').addEventListener('input', function() {
                    brushOpacity = parseFloat(this.value);
                    document.getElementById('brush-opacity-value').textContent = Math.round(brushOpacity * 100);
                    updateBrushPreview();
                });

                // Color wheel
                document.getElementById('color-wheel').onclick = handleColorWheelClick;

                // Hex color input
                document.getElementById('apply-hex').addEventListener('click', applyHexColor);
                document.getElementById('color-hex').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') applyHexColor();
                });

                // Monochromatic toggle
                document.getElementById('monochromatic-toggle').addEventListener('change', function() {
                    isMonochromatic = this.checked;
                    if (isMonochromatic) {
                        const hsl = hexToHsl(currentColor);
                        baseHsl = { h: hsl.h, s: 100, l: 50 };
                        updateColorWheelForMonochromatic(baseHsl.h);
                        currentColor = hslToHex(baseHsl.h, 100, 50);
                    } else {
                        restoreColorWheel();
                        currentColor = hslToHex(baseHsl.h, 100, 50);
                    }
                    updateCurrentColor(currentColor);
                    updateColorTheory(currentColor);
                });

                // Background selection
                document.querySelectorAll('[data-bg]').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const bg = this.getAttribute('data-bg');
                        setBackground(bg);
                    });
                });

                // Custom background upload
                document.getElementById('custom-bg').addEventListener('click', function() {
                    document.getElementById('bg-upload').click();
                });

                document.getElementById('bg-upload').addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const img = new Image();
                            img.onload = function() {
                                mainCtx.drawImage(img, 0, 0, mainCanvas.width, mainCanvas.height);
                                saveCanvasState();
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                });

                // Clear canvas
                document.getElementById('clear-canvas').addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear the canvas?')) {
                        mainCtx.fillStyle = 'white';
                        mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                        saveCanvasState();
                    }
                });

                // Save image
                document.getElementById('save-image').addEventListener('click', function() {
                    const link = document.createElement('a');
                    link.download = 'graffiti-art.png';
                    link.href = mainCanvas.toDataURL('image/png');
                    link.click();
                });

                // Undo/redo
                document.getElementById('undo').addEventListener('click', undo);
                document.getElementById('redo').addEventListener('click', redo);

                // Trace layer toggle
                document.getElementById('toggle-trace-layer').addEventListener('click', function() {
                    isTraceLayerVisible = !isTraceLayerVisible;
                    traceCanvas.style.display = isTraceLayerVisible ? 'block' : 'none';
                    this.classList.toggle('bg-blue-500', isTraceLayerVisible);
                    this.classList.toggle('bg-gray-500', !isTraceLayerVisible);
                });

                // Mandala mode toggle
                document.getElementById('toggle-mandala').addEventListener('click', function() {
                    isMandalaMode = !isMandalaMode;
                    document.getElementById('mandala-settings').style.display = isMandalaMode ? 'block' : 'none';
                    document.getElementById('symmetry-lines').style.display = isMandalaMode ? 'block' : 'none';
                    this.classList.toggle('bg-purple-500', isMandalaMode);
                    this.classList.toggle('bg-gray-500', !isMandalaMode);

                    if (isMandalaMode) {
                        updateSymmetryLines();
                    }
                });

                // Mandala symmetry points
                document.getElementById('symmetry-points').addEventListener('input', function() {
                    mandalaSymmetryPoints = parseInt(this.value);
                    document.getElementById('symmetry-points-value').textContent = mandalaSymmetryPoints;
                    updateSymmetryLines();
                });

                // Mandala color mode
                document.getElementById('mandala-solid').addEventListener('click', function() {
                    mandalaColorMode = 'solid';
                    document.getElementById('mandala-solid').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('mandala-solid').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-gradient').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-gradient').classList.remove('bg-blue-500', 'text-white');
                    document.getElementById('gradient-colors').style.display = 'none';
                });

                document.getElementById('mandala-gradient').addEventListener('click', function() {
                    mandalaColorMode = 'gradient';
                    document.getElementById('mandala-gradient').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('mandala-gradient').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-solid').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-solid').classList.remove('bg-blue-500', 'text-white');
                    document.getElementById('gradient-colors').style.display = 'block';
                });

                // Gradient colors
                document.getElementById('gradient-start').addEventListener('input', function() {
                    gradientStart = this.value;
                });

                document.getElementById('gradient-end').addEventListener('input', function() {
                    gradientEnd = this.value;
                });

                // Letter case
                document.getElementById('upper-case').addEventListener('click', function() {
                    currentLetterCase = 'upper';
                    document.getElementById('upper-case').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('upper-case').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('lower-case').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('lower-case').classList.remove('bg-blue-500', 'text-white');
                    initLetters();
                });

                document.getElementById('lower-case').addEventListener('click', function() {
                    currentLetterCase = 'lower';
                    document.getElementById('lower-case').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('lower-case').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('upper-case').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('upper-case').classList.remove('bg-blue-500', 'text-white');
                    initLetters();
                });

                // Letter style
                document.getElementById('letter-style').addEventListener('change', function() {
                    currentLetterStyle = this.value;
                    initLetters();
                });

                // Clear letters
                document.getElementById('clear-letters').addEventListener('click', function() {
                    traceCtx.clearRect(0, 0, traceCanvas.width, traceCanvas.height);
                });

                // Color theory info
                document.querySelectorAll('.color-theory-box').forEach(box => {
                    box.addEventListener('click', function() {
                        const type = this.id;
                        showColorTheoryInfo(type);
                    });
                });

                // Close color theory modal
                document.getElementById('close-color-modal').addEventListener('click', function() {
                    document.getElementById('color-theory-modal').classList.add('hidden');
                });
            }

            // Drawing functions
            function startDrawing(e) {
                isDrawing = true;
                const pos = getPosition(e);
                [lastX, lastY] = [pos.x, pos.y];
                if (currentBrush === 'spray') draw(e);
            }

            function draw(e) {
                if (!isDrawing) return;
                const pos = getPosition(e);
                const x = pos.x;
                const y = pos.y;
                mainCtx.globalAlpha = brushOpacity;
                if (isMandalaMode) {
                    drawWithSymmetry(x, y);
                } else {
                    drawLine(lastX, lastY, x, y);
                }
                [lastX, lastY] = [x, y];
                if (currentBrush === 'spray') {
                    lastX = x;
                    lastY = y;
                }
            }

            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    saveCanvasState();
                }
            }

            function drawLine(x1, y1, x2, y2) {
                mainCtx.beginPath();
                mainCtx.moveTo(x1, y1);
                mainCtx.lineTo(x2, y2);
                switch (currentBrush) {
                    case 'standard':
                        mainCtx.lineCap = 'round';
                        mainCtx.lineJoin = 'round';
                        mainCtx.lineWidth = brushSize;
                        mainCtx.strokeStyle = currentColor;
                        mainCtx.stroke();
                        break;
                    case 'calligraphy':
                        mainCtx.lineWidth = brushSize;
                        mainCtx.strokeStyle = currentColor;
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const lineWidth = brushSize * (0.5 + 0.5 * Math.abs(Math.sin(angle)));
                        mainCtx.lineWidth = lineWidth;
                        mainCtx.stroke();
                        break;
                    case 'spray':
                        const density = brushSize * 2;
                        const radius = brushSize * 2;
                        for (let i = 0; i < density; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * radius;
                            const sprayX = x2 + Math.cos(angle) * dist;
                            const sprayY = y2 + Math.sin(angle) * dist;
                            const sprayOpacity = brushOpacity * (0.3 + Math.random() * 0.7);
                            mainCtx.globalAlpha = sprayOpacity;
                            mainCtx.fillStyle = currentColor;
                            mainCtx.beginPath();
                            mainCtx.arc(sprayX, sprayY, 1 + Math.random() * 2, 0, Math.PI * 2);
                            mainCtx.fill();
                        }
                        break;
                    case 'marker':
                        mainCtx.lineWidth = brushSize;
                        mainCtx.strokeStyle = currentColor;
                        const steps = 3;
                        for (let i = 0; i < steps; i++) {
                            const opacity = brushOpacity * (0.3 + 0.7 * (i / steps));
                            mainCtx.globalAlpha = opacity;
                            mainCtx.lineWidth = brushSize * (1 - i * 0.2);
                            mainCtx.stroke();
                        }
                        break;
                    case 'eraser':
                        mainCtx.globalCompositeOperation = 'destination-out';
                        mainCtx.lineCap = 'round';
                        mainCtx.lineJoin = 'round';
                        mainCtx.lineWidth = brushSize;
                        mainCtx.stroke();
                        mainCtx.globalCompositeOperation = 'source-over';
                        break;
                }
                mainCtx.globalAlpha = 1;
            }

            function drawWithSymmetry(x, y) {
                const centerX = mainCanvas.width / 2;
                const centerY = mainCanvas.height / 2;
                const angleStep = (2 * Math.PI) / mandalaSymmetryPoints;
                for (let i = 0; i < mandalaSymmetryPoints; i++) {
                    const angle = i * angleStep;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const mirroredX = centerX + dx * Math.cos(angle) + dy * Math.sin(angle);
                    const mirroredY = centerY + -dx * Math.sin(angle) + dy * Math.cos(angle);
                    const lastDx = lastX - centerX;
                    const lastDy = lastY - centerY;
                    const mirroredLastX = centerX + lastDx * Math.cos(angle) + lastDy * Math.sin(angle);
                    const mirroredLastY = centerY + -lastDx * Math.sin(angle) + lastDy * Math.cos(angle);
                    if (mandalaColorMode === 'gradient') {
                        const t = i / mandalaSymmetryPoints;
                        currentColor = interpolateColor(gradientStart, gradientEnd, t);
                    }
                    drawLine(mirroredLastX, mirroredLastY, mirroredX, mirroredY);
                }
                if (mandalaColorMode === 'gradient') {
                    currentColor = interpolateColor(gradientStart, gradientEnd, 0);
                }
            }

            function interpolateColor(color1, color2, factor) {
                if (factor === undefined) factor = 0.5;
                const r1 = parseInt(color1.substring(1, 3), 16);
                const g1 = parseInt(color1.substring(3, 5), 16);
                const b1 = parseInt(color1.substring(5, 7), 16);
                const r2 = parseInt(color2.substring(1, 3), 16);
                const g2 = parseInt(color2.substring(3, 5), 16);
                const b2 = parseInt(color2.substring(5, 7), 16);
                const r = Math.round(r1 + factor * (r2 - r1));
                const g = Math.round(g1 + factor * (g2 - g1));
                const b = Math.round(b1 + factor * (b2 - b1));
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }

            // Touch event handlers
            function handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                mainCanvas.dispatchEvent(mouseEvent);
            }
            function handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                mainCanvas.dispatchEvent(mouseEvent);
            }
            function handleTouchEnd(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup');
                mainCanvas.dispatchEvent(mouseEvent);
            }

            function getPosition(e) {
                const rect = mainCanvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            // Color wheel
            function initColorWheel() {
                updateCurrentColor(currentColor);
            }

            function handleColorWheelClick(e) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > centerX) return;
                if (isMonochromatic) {
                    const lightness = Math.max(0, Math.min(100, (distance / centerX) * 100));
                    currentColor = hslToHex(baseHsl.h, 100, lightness);
                } else {
                    let angle = Math.atan2(dy, dx) - Math.PI / 2 + Math.PI;
                    if (angle < 0) angle += 2 * Math.PI;
                    const hue = (angle * 180 / Math.PI) % 360;
                    const saturation = Math.max(0, Math.min(100, (distance / centerX) * 100));
                    currentColor = hslToHex(hue, saturation, 50);
                    baseHsl = { h: hue, s: 100, l: 50 };
                }
                updateCurrentColor(currentColor);
                updateColorTheory(currentColor);
                addToPalette(currentColor);
            }

            function hslToHex(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            function hexToHsl(hex) {
                let r = 0, g = 0, b = 0;
                if (hex.length === 4) {
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length === 7) {
                    r = parseInt(hex.substring(1, 3), 16);
                    g = parseInt(hex.substring(3, 5), 16);
                    b = parseInt(hex.substring(5, 7), 16);
                }
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return {
                    h: h * 360,
                    s: s * 100,
                    l: l * 100
                };
            }

            function applyHexColor() {
                const hexInput = document.getElementById('color-hex');
                let hex = hexInput.value.trim();
                if (!/^#[0-9A-F]{6}$/i.test(hex) && !/^#[0-9A-F]{3}$/i.test(hex)) {
                    alert('Please enter a valid hex color (e.g., #FF0000 or #F00)');
                    return;
                }
                if (hex.length === 4) {
                    hex = `#${hex[1]}${hex[1]}${hex[2]}${hex[2]}${hex[3]}${hex[3]}`;
                    hexInput.value = hex;
                }
                currentColor = hex;
                updateCurrentColor(hex);
                updateColorTheory(hex);
                addToPalette(currentColor);
            }

            function updateCurrentColor(color) {
                document.getElementById('current-color').style.backgroundColor = color;
                document.getElementById('color-hex').value = color;
                const hsl = hexToHsl(color);
                let angle, radius;
                const centerX = 100;
                const centerY = 100;
                if (isMonochromatic) {
                    angle = -Math.PI / 2;
                    radius = (hsl.l / 100) * 100;
                } else {
                    angle = ((hsl.h / 360) * 2 * Math.PI) - Math.PI / 2;
                    radius = (hsl.s / 100) * 100;
                }
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const indicator = document.querySelector('.color-wheel div');
                indicator.style.left = `${x}px`;
                indicator.style.top = `${y}px`;
            }

            function updateColorTheory(baseColor) {
                const hsl = hexToHsl(baseColor);
                // Complementary color (180°)
                const complementaryH = (hsl.h + 180) % 360;
                const complementaryColor = hslToHex(complementaryH, hsl.s, hsl.l);
                document.getElementById('complementary').style.backgroundColor = complementaryColor;
                // Triadic colors (120° and 240°)
                const triadic1H = (hsl.h + 120) % 360;
                const triadic2H = (hsl.h + 240) % 360;
                const triadic1Color = hslToHex(triadic1H, hsl.s, hsl.l);
                const triadic2Color = hslToHex(triadic2H, hsl.s, hsl.l);
                document.getElementById('triadic1').style.backgroundColor = triadic1Color;
                document.getElementById('triadic2').style.backgroundColor = triadic2Color;
                // Analogous colors (30° and -30°)
                const analogous1H = (hsl.h + 30) % 360;
                const analogous2H = (hsl.h - 30 + 360) % 360;
                const analogous1Color = hslToHex(analogous1H, hsl.s, hsl.l);
                const analogous2Color = hslToHex(analogous2H, hsl.s, hsl.l);
                document.getElementById('analogous1').style.backgroundColor = analogous1Color;
                document.getElementById('analogous2').style.backgroundColor = analogous2Color;
                // Tetradic colors (90°, 180°, 270°)
                const tetradic1H = (hsl.h + 90) % 360;
                const tetradic2H = (hsl.h + 180) % 360;
                const tetradic3H = (hsl.h + 270) % 360;
                const tetradic1Color = hslToHex(tetradic1H, hsl.s, hsl.l);
                const tetradic2Color = hslToHex(tetradic2H, hsl.s, hsl.l);
                const tetradic3Color = hslToHex(tetradic3H, hsl.s, hsl.l);
                document.getElementById('tetradic1').style.backgroundColor = tetradic1Color;
                document.getElementById('tetradic2').style.backgroundColor = tetradic2Color;
                document.getElementById('tetradic3').style.backgroundColor = tetradic3Color;
                if (isMonochromatic) {
                    updateColorWheelForMonochromatic(hsl.h);
                } else {
                    restoreColorWheel();
                }
            }

            function updateColorWheelForMonochromatic(hue) {
                const colorWheel = document.getElementById('color-wheel');
                colorWheel.style.background = `radial-gradient(circle,
                    ${hslToHex(hue, 100, 0)} 0%,
                    ${hslToHex(hue, 100, 50)} 60%,
                    #ffffff 100%)`;
            }

            function restoreColorWheel() {
                const colorWheel = document.getElementById('color-wheel');
                colorWheel.style.background = 'conic-gradient(red, yellow, lime, cyan, blue, magenta, red)';
            }

            // Persistent palette
            function addToPalette(color) {
                if (recentColors[recentColors.length - 1] !== color) {
                    recentColors.push(color);
                    if (recentColors.length > 5) recentColors.shift();
                    updatePaletteDisplay();
                }
            }
            function updatePaletteDisplay() {
                const palette = document.getElementById('recent-palette');
                if (!palette) return;
                palette.innerHTML = '';
                recentColors.forEach(col => {
                    const swatch = document.createElement('div');
                    swatch.className = 'w-6 h-6 rounded border inline-block cursor-pointer mr-1';
                    swatch.style.backgroundColor = col;
                    swatch.title = col;
                    swatch.onclick = () => {
                        currentColor = col;
                        updateCurrentColor(col);
                        updateColorTheory(col);
                    };
                    palette.appendChild(swatch);
                });
            }

            // Traceable letters
            function initLetters() {
                const lettersGrid = document.getElementById('letters-grid');
                lettersGrid.innerHTML = '';
                const letters = currentLetterCase === 'upper' ?
                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' :
                    'abcdefghijklmnopqrstuvwxyz';
                for (let letter of letters) {
                    const letterBtn = document.createElement('button');
                    letterBtn.className = 'w-8 h-8 rounded border flex items-center justify-center bg-gray-100 hover:bg-gray-200';
                    letterBtn.textContent = letter;
                    letterBtn.title = `Add ${letter} to trace layer`;
                    switch (currentLetterStyle) {
                        case 'block':
                            letterBtn.style.fontFamily = 'Arial Black, sans-serif';
                            letterBtn.style.fontWeight = 'bold';
                            break;
                        case 'bubble':
                            letterBtn.style.fontFamily = 'Comic Sans MS, cursive';
                            letterBtn.style.fontWeight = 'bold';
                            break;
                        case 'wildstyle':
                            letterBtn.style.fontFamily = 'Impact, sans-serif';
                            letterBtn.style.fontWeight = 'bold';
                            letterBtn.style.transform = 'skewX(-10deg)';
                            break;
                        case 'tag':
                            letterBtn.style.fontFamily = 'Courier New, monospace';
                            letterBtn.style.fontWeight = 'bold';
                            break;
                    }
                    letterBtn.addEventListener('click', function() {
                        addLetterToTraceLayer(letter);
                    });
                    lettersGrid.appendChild(letterBtn);
                }
            }

            function addLetterToTraceLayer(letter) {
                const size = prompt('Enter letter size (10-100):', '80');
                if (!size || isNaN(size) || size < 10 || size > 100) {
                    alert('Please enter a valid size between 10 and 100');
                    return;
                }
                const x = mainCanvas.width / 2 - parseInt(size) / 2;
                const y = mainCanvas.height / 2 - parseInt(size) / 2;
                traceCanvas.style.display = 'block';

                // Use image instead of font
                const img = new Image();
                // Use uppercase for filenames, e.g. /letters/A.png
                img.src = `/letters/${letter.toUpperCase()}.png`;
                img.onload = function() {
                    // Optional: clear previous trace
                    traceCtx.clearRect(0, 0, traceCanvas.width, traceCanvas.height);
                    traceCtx.globalAlpha = 0.7;
                    traceCtx.drawImage(img, x, y, size, size);
                    traceCtx.globalAlpha = 1;
                };
                img.onerror = function() {
                    alert(`Image for letter "${letter}" not found. Please upload /letters/${letter.toUpperCase()}.png`);
                };
            }

            // Undo/redo
            function saveCanvasState() {
                const imageData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
                undoStack.push(imageData);
                if (undoStack.length > MAX_UNDO_STEPS) {
                    undoStack.shift();
                }
                redoStack = [];
                document.getElementById('undo').disabled = undoStack.length <= 1;
                document.getElementById('redo').disabled = true;
            }
            function undo() {
                if (undoStack.length > 1) {
                    const currentState = undoStack.pop();
                    redoStack.push(currentState);
                    const prevState = undoStack[undoStack.length - 1];
                    mainCtx.putImageData(prevState, 0, 0);
                    document.getElementById('redo').disabled = false;
                    document.getElementById('undo').disabled = undoStack.length <= 1;
                }
            }
            function redo() {
                if (redoStack.length > 0) {
                    const nextState = redoStack.pop();
                    undoStack.push(nextState);
                    mainCtx.putImageData(nextState, 0, 0);
                    document.getElementById('undo').disabled = false;
                    document.getElementById('redo').disabled = redoStack.length === 0;
                }
            }

            // Mandala symmetry lines
            function updateSymmetryLines() {
                const container = document.getElementById('symmetry-lines');
                container.innerHTML = '';
                const centerX = mainCanvas.width / 2;
                const angleStep = (2 * Math.PI) / mandalaSymmetryPoints;
                for (let i = 0; i < mandalaSymmetryPoints; i++) {
                    const line = document.createElement('div');
                    line.className = 'symmetry-line';
                    line.style.left = `${centerX}px`;
                    line.style.transform = `rotate(${i * angleStep}rad)`;
                    container.appendChild(line);
                }
            }

            // Color theory modal
            function showColorTheoryInfo(type) {
                const modal = document.getElementById('color-theory-modal');
                const title = document.getElementById('color-theory-title');
                const content = document.getElementById('color-theory-content');
                modal.classList.remove('hidden');
                let info = '';
                switch (type) {
                    case 'complementary':
                        title.textContent = 'Complementary Colors';
                        info = `
                            <p class="mb-4">Complementary colors are pairs of colors which, when combined, cancel each other out. This means that when placed next to each other, they create the strongest contrast.</p>
                            <p>In color theory, complementary colors are opposite each other on the color wheel. For example, red and green are complementary colors.</p>
                        `;
                        break;
                    case 'triadic1':
                    case 'triadic2':
                        title.textContent = 'Triadic Color Scheme';
                        info = `
                            <p class="mb-4">A triadic color scheme uses three colors that are evenly spaced around the color wheel.</p>
                            <p>Triadic color harmonies tend to be quite vibrant, even if you use pale or unsaturated versions of your hues. To use a triadic harmony successfully, the colors should be carefully balanced - let one color dominate and use the two others for accent.</p>
                        `;
                        break;
                    case 'analogous1':
                    case 'analogous2':
                        title.textContent = 'Analogous Colors';
                        info = `
                            <p class="mb-4">Analogous colors are groups of three colors that are next to each other on the color wheel, sharing a common color, with one being the dominant color, which tends to be a primary or secondary color, and a tertiary.</p>
                            <p>Analogous color schemes are often found in nature and are harmonious and pleasing to the eye. They usually match well and create serene and comfortable designs.</p>
                        `;
                        break;
                    case 'tetradic1':
                    case 'tetradic2':
                    case 'tetradic3':
                        title.textContent = 'Tetradic Color Scheme';
                        info = `
                            <p class="mb-4">A tetradic color scheme, also known as double-complementary, uses four colors arranged into two complementary pairs.</p>
                            <p>This rich color scheme offers plenty of possibilities for variation. Tetradic color schemes work best if you let one color be dominant, and use the others as accents. The more colors you have in your palette, the more difficult it is to balance.</p>
                        `;
                        break;
                }
                content.innerHTML = info;
            }

            // Brush preview
            function updateBrushPreview() {
                const preview = document.getElementById('brush-preview-line');
                preview.style.backgroundColor = currentColor;
                preview.style.width = `${brushSize}px`;
                preview.style.height = `${brushSize}px`;
                preview.style.borderRadius = currentBrush === 'spray' ? '50%' : '0';
                if (currentBrush === 'calligraphy') {
                    preview.style.width = `${brushSize}px`;
                    preview.style.height = `${brushSize * 2}px`;
                    preview.style.borderRadius = '0';
                }
                if (currentBrush === 'marker') {
                    preview.style.width = `${brushSize}px`;
                    preview.style.height = `${brushSize}px`;
                    preview.style.borderRadius = '0';
                    preview.style.opacity = '0.7';
                }
                if (currentBrush === 'spray') {
                    preview.style.width = `${brushSize * 2}px`;
                    preview.style.height = `${brushSize * 2}px`;
                    preview.style.borderRadius = '50%';
                }
            }

            // Backgrounds
            function setBackground(bg) {
                switch (bg) {
                    case 'white':
                        mainCtx.fillStyle = 'white';
                        break;
                    case 'black':
                        mainCtx.fillStyle = 'black';
                        break;
                    case 'brick':
                        drawBrickBackground();
                        return;
                    case 'concrete':
                        drawConcreteBackground();
                        return;
                    case 'wood':
                        drawWoodBackground();
                        return;
                }
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                saveCanvasState();
            }
            function drawBrickBackground() {
                const brickWidth = 60;
                const brickHeight = 30;
                const mortar = 5;
                mainCtx.fillStyle = '#b22222';
                for (let y = 0; y < mainCanvas.height; y += brickHeight + mortar) {
                    const offset = (y / (brickHeight + mortar)) % 2 ? brickWidth / 2 : 0;
                    for (let x = -offset; x < mainCanvas.width; x += brickWidth + mortar) {
                        mainCtx.fillRect(x, y, brickWidth, brickHeight);
                    }
                }
                mainCtx.fillStyle = '#8B8B7A';
                for (let y = 0; y < mainCanvas.height; y += brickHeight + mortar) {
                    mainCtx.fillRect(0, y + brickHeight, mainCanvas.width, mortar);
                }
                for (let y = 0; y < mainCanvas.height; y += brickHeight + mortar) {
                    const offset = (y / (brickHeight + mortar)) % 2 ? brickWidth / 2 : 0;
                    for (let x = offset; x < mainCanvas.width; x += brickWidth + mortar) {
                        mainCtx.fillRect(x, y, mortar, brickHeight);
                    }
                }
                saveCanvasState();
            }
            function drawConcreteBackground() {
                mainCtx.fillStyle = '#7a7a7a';
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                const imageData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const variation = Math.floor(Math.random() * 20) - 10;
                    data[i] += variation;
                    data[i + 1] += variation;
                    data[i + 2] += variation;
                }
                mainCtx.putImageData(imageData, 0, 0);
                mainCtx.strokeStyle = '#5a5a5a';
                mainCtx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const startX = Math.random() * mainCanvas.width;
                    const startY = Math.random() * mainCanvas.height;
                    const length = 50 + Math.random() * 100;
                    const angle = Math.random() * Math.PI * 2;
                    mainCtx.beginPath();
                    mainCtx.moveTo(startX, startY);
                    let x = startX;
                    let y = startY;
                    const segments = 5 + Math.floor(Math.random() * 5);
                    for (let s = 0; s < segments; s++) {
                        x += Math.cos(angle) * (length / segments) * (0.8 + Math.random() * 0.4);
                        y += Math.sin(angle) * (length / segments) * (0.8 + Math.random() * 0.4);
                        const segmentAngle = angle + (Math.random() - 0.5) * 0.5;
                        x += Math.cos(segmentAngle) * (length / segments / 2);
                        y += Math.sin(segmentAngle) * (length / segments / 2);
                        mainCtx.lineTo(x, y);
                    }
                    mainCtx.stroke();
                }
                saveCanvasState();
            }
            function drawWoodBackground() {
                const baseColor = '#8B4513';
                const hsl = hexToHsl(baseColor);
                for (let x = 0; x < mainCanvas.width; x++) {
                    const variation = Math.sin(x / 30) * 5;
                    const lightness = hsl.l + variation;
                    const color = hslToHex(hsl.h, hsl.s, lightness);
                    mainCtx.fillStyle = color;
                    mainCtx.fillRect(x, 0, 1, mainCanvas.height);
                }
                mainCtx.strokeStyle = '#5D2906';
                mainCtx.lineWidth = 1;
                for (let i = 0; i < 10; i++) {
                    const y = Math.random() * mainCanvas.height;
                    const wavyness = 2 + Math.random() * 3;
                    mainCtx.beginPath();
                    mainCtx.moveTo(0, y);
                    for (let x = 0; x < mainCanvas.width; x += 10) {
                        const nextY = y + Math.sin(x / 50) * wavyness;
                        mainCtx.lineTo(x, nextY);
                    }
                    mainCtx.stroke();
                }
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * mainCanvas.width;
                    const y = Math.random() * mainCanvas.height;
                    const size = 10 + Math.random() * 20;
                    mainCtx.fillStyle = '#5D2906';
                    mainCtx.beginPath();
                    mainCtx.ellipse(x, y, size, size * 0.5, 0, 0, Math.PI * 2);
                    mainCtx.fill();
                    mainCtx.strokeStyle = '#5D2906';
                    mainCtx.lineWidth = 1;
                    for (let r = size + 5; r < size + 20; r += 3) {
                        mainCtx.beginPath();
                        mainCtx.ellipse(x, y, r, r * 0.5, 0, 0, Math.PI * 2);
                        mainCtx.stroke();
                    }
                }
                saveCanvasState();
            }

            // Start the app
            initCanvas();
        });
    </script>
</body>
</html>

