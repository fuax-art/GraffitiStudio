<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graffiti Art Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom CSS for color wheel and other elements */
       .color-wheel {
           width: 200px;
           height: 200px;
           border-radius: 50%;
           background: conic-gradient(
               red, yellow, lime, cyan, blue, magenta, red
           );
           position: relative;
           cursor: crosshair;
       }
      
       .color-preview {
           width: 50px;
           height: 50px;
           border-radius: 50%;
           border: 2px solid white;
           box-shadow: 0 0 5px rgba(0,0,0,0.5);
       }
      
       .color-theory-box {
           width: 30px;
           height: 30px;
           border: 1px solid #333;
           cursor: pointer;
       }
        
        .brush-preview {
            width: 100%;
            height: 40px;
            border: 1px solid #ccc;
            background-color: white;
        }
        
        canvas {
            touch-action: none;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        
        .tool-btn.active {
            background-color: #3b82f6;
            color: white;
        }
        
        .symmetry-line {
            position: absolute;
            background-color: rgba(255,0,0,0.3);
            width: 1px;
            height: 100%;
            top: 0;
            left: 50%;
            transform-origin: center;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Animation for spray can */
        @keyframes spray {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        .spray-animation {
            animation: spray 0.5s infinite;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto px-4 py-6">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-gray-800 flex items-center">
                <i class="fas fa-spray-can text-blue-500 mr-2 spray-animation"></i>
                Graffiti Art Studio
            </h1>
            <p class="text-gray-600">Create stunning street art with our digital tools</p>
        </header>
        
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Left sidebar - Tools -->
            <div class="w-full lg:w-64 bg-white rounded-lg shadow p-4">
                <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                    <i class="fas fa-tools mr-2"></i>Tools
                </h2>
                
                <!-- Brush selection -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <i class="fas fa-paint-brush mr-2"></i>Brush Type
                    </h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button id="brush-standard" class="tool-btn active p-2 rounded border hover:bg-gray-100" title="Standard Brush">
                            <i class="fas fa-pen"></i>
                        </button>
                        <button id="brush-calligraphy" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Calligraphy">
                            <i class="fas fa-pen-nib"></i>
                        </button>
                        <button id="brush-spray" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Spray Paint">
                            <i class="fas fa-spray-can"></i>
                        </button>
                        <button id="brush-marker" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Marker">
                            <i class="fas fa-highlighter"></i>
                        </button>
                        <button id="brush-eraser" class="tool-btn p-2 rounded border hover:bg-gray-100" title="Eraser">
                            <i class="fas fa-eraser"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Brush size -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <i class="fas fa-arrows-alt-h mr-2"></i>Brush Size
                    </h3>
                    <input type="range" id="brush-size" min="1" max="50" value="5" class="w-full">
                    <div class="text-center mt-1 text-sm text-gray-600">
                        Size: <span id="brush-size-value">5</span>px
                    </div>
                </div>
                
                <!-- Brush opacity -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <i class="fas fa-adjust mr-2"></i>Opacity
                    </h3>
                    <input type="range" id="brush-opacity" min="0.1" max="1" step="0.1" value="1" class="w-full">
                    <div class="text-center mt-1 text-sm text-gray-600">
                        Opacity: <span id="brush-opacity-value">100</span>%
                    </div>
                </div>
                
                <!-- Brush preview -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-2">Preview</h3>
                    <div class="brush-preview flex items-center justify-center">
                        <div id="brush-preview-line" class="h-1 bg-black rounded-full"></div>
                    </div>
                </div>
                
                <!-- Clear canvas -->
                <button id="clear-canvas" class="w-full bg-red-500 hover:bg-red-600 text-white py-2 rounded flex items-center justify-center">
                    <i class="fas fa-trash mr-2"></i> Clear Canvas
                </button>
            </div>
            
            <!-- Main canvas area -->
            <div class="flex-1">
                <div class="bg-white rounded-lg shadow p-4">
                    <!-- Canvas controls -->
                    <div class="flex flex-wrap justify-between items-center mb-4">
                        <div class="flex space-x-2 mb-2 sm:mb-0">
                            <button id="toggle-trace-layer" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded flex items-center">
                                <i class="fas fa-layer-group mr-1"></i> Trace Layer
                            </button>
                            <button id="toggle-mandala" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded flex items-center">
                                <i class="fas fa-snowflake mr-1"></i> Mandala Mode
                            </button>
                        </div>
                        
                        <div class="flex space-x-2">
                            <button id="undo" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded flex items-center" title="Undo">
                                <i class="fas fa-undo mr-1"></i>
                            </button>
                            <button id="redo" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded flex items-center" title="Redo">
                                <i class="fas fa-redo mr-1"></i>
                            </button>
                            <button id="save-image" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded flex items-center">
                                <i class="fas fa-download mr-1"></i> Save
                            </button>
                        </div>
                    </div>
                    
                    <!-- Canvas container -->
                    <div class="relative border-2 border-gray-200 rounded overflow-hidden">
                        <canvas id="main-canvas" width="800" height="600"></canvas>
                        <canvas id="trace-canvas" width="800" height="600" class="absolute top-0 left-0 pointer-events-none opacity-50" style="display: none;"></canvas>
                        <div id="symmetry-lines" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="display: none;"></div>
                    </div>
                    
                    <!-- Background selection -->
                    <div class="mt-4">
                        <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                            <i class="fas fa-image mr-2"></i>Background
                        </h3>
                        <div class="flex flex-wrap gap-2">
                            <button data-bg="white" class="w-10 h-10 rounded border-2 border-gray-300 bg-white"></button>
                            <button data-bg="black" class="w-10 h-10 rounded border-2 border-gray-300 bg-black"></button>
                            <button data-bg="brick" class="w-10 h-10 rounded border-2 border-gray-300 bg-gray-300 flex items-center justify-center">
                                <i class="fas fa-bricks text-gray-600"></i>
                            </button>
                            <button data-bg="concrete" class="w-10 h-10 rounded border-2 border-gray-300 bg-gray-400 flex items-center justify-center">
                                <i class="fas fa-road text-gray-700"></i>
                            </button>
                            <button data-bg="wood" class="w-10 h-10 rounded border-2 border-gray-300 bg-amber-700 flex items-center justify-center">
                                <i class="fas fa-tree text-amber-900"></i>
                            </button>
                            <button id="custom-bg" class="w-10 h-10 rounded border-2 border-gray-300 bg-gray-100 flex items-center justify-center">
                                <i class="fas fa-upload text-gray-600"></i>
                            </button>
                            <input type="file" id="bg-upload" class="hidden" accept="image/*">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right sidebar - Color and letters -->
            <div class="w-full lg:w-64 bg-white rounded-lg shadow p-4">
                <!-- Color selection -->
                <div class="mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                        <i class="fas fa-palette mr-2"></i>Color
                    </h2>
                    
                    <!-- Current color preview -->
                    <div class="flex justify-center mb-4">
                        <div id="current-color" class="color-preview" style="background-color: #000000;"></div>
                    </div>
                    
                    <!-- Color wheel -->
                    <div class="flex justify-center mb-4">
                        <div class="color-wheel" id="color-wheel">
                            <div class="w-3 h-3 bg-white rounded-full absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none"></div>
                        </div>
                    </div>
                    
                    <!-- Color picker -->
                    <div class="mb-4">
                        <label for="color-hex" class="block text-sm font-medium text-gray-700 mb-1">Hex:</label>
                        <div class="flex">
                            <input type="text" id="color-hex" value="#000000" class="flex-1 border rounded-l px-2 py-1">
                            <button id="apply-hex" class="bg-blue-500 text-white px-2 py-1 rounded-r">
                                <i class="fas fa-check"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Monochromatic toggle -->
                    <div class="flex items-center mb-4">
                        <input type="checkbox" id="monochromatic-toggle" class="mr-2">
                        <label for="monochromatic-toggle" class="text-sm text-gray-700">Monochromatic</label>
                    </div>
                    
                    <!-- Color theory -->
                    <div class="mb-6">
                        <h3 class="font-medium text-gray-700 mb-2">Color Theory</h3>
                        <div class="grid grid-cols-4 gap-2">
                            <div>
                                <div id="complementary" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Complement</p>
                            </div>
                            <div>
                                <div id="triadic1" class="color-theory-box mx-auto mb-1"></div>
                                <div id="triadic2" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Triadic</p>
                            </div>
                            <div>
                                <div id="analogous1" class="color-theory-box mx-auto mb-1"></div>
                                <div id="analogous2" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Analogous</p>
                            </div>
                            <div>
                                <div id="tetradic1" class="color-theory-box mx-auto mb-1"></div>
                                <div id="tetradic2" class="color-theory-box mx-auto mb-1"></div>
                                <div id="tetradic3" class="color-theory-box mx-auto mb-1"></div>
                                <p class="text-xs text-center">Tetradic</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Mandala settings (hidden by default) -->
                <div id="mandala-settings" class="mb-6" style="display: none;">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                        <i class="fas fa-snowflake mr-2"></i>Mandala
                    </h2>
                    
                    <div class="mb-4">
                        <label for="symmetry-points" class="block text-sm font-medium text-gray-700 mb-1">Symmetry Points:</label>
                        <input type="range" id="symmetry-points" min="2" max="99" value="6" class="w-full">
                        <div class="text-center mt-1 text-sm text-gray-600">
                            Points: <span id="symmetry-points-value">6</span>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Color Mode:</label>
                        <div class="flex space-x-2">
                            <button id="mandala-solid" class="flex-1 bg-blue-500 text-white py-1 px-2 rounded text-sm">Solid</button>
                            <button id="mandala-gradient" class="flex-1 bg-gray-200 text-gray-800 py-1 px-2 rounded text-sm">Gradient</button>
                        </div>
                    </div>
                    
                    <div id="gradient-colors" class="space-y-2" style="display: none;">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Gradient Colors:</label>
                        <div class="flex space-x-2">
                            <input type="color" id="gradient-start" value="#ff0000" class="w-8 h-8">
                            <input type="color" id="gradient-end" value="#0000ff" class="w-8 h-8">
                        </div>
                    </div>
                </div>
                
                <!-- Traceable letters -->
                <div id="letters-section">
                    <h2 class="text-xl font-semibold mb-4 text-gray-700 border-b pb-2">
                        <i class="fas fa-font mr-2"></i>Traceable Letters
                    </h2>
                    
                    <div class="mb-4">
                        <label for="letter-style" class="block text-sm font-medium text-gray-700 mb-1">Style:</label>
                        <select id="letter-style" class="w-full border rounded px-2 py-1">
                            <option value="block">Block</option>
                            <option value="bubble">Bubble</option>
                            <option value="wildstyle">Wildstyle</option>
                            <option value="tag">Tag</option>
                        </select>
                    </div>
                    
                    <div class="mb-4">
                        <label for="letter-case" class="block text-sm font-medium text-gray-700 mb-1">Case:</label>
                        <div class="flex space-x-2">
                            <button id="upper-case" class="flex-1 bg-blue-500 text-white py-1 px-2 rounded text-sm">Uppercase</button>
                            <button id="lower-case" class="flex-1 bg-gray-200 text-gray-800 py-1 px-2 rounded text-sm">Lowercase</button>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-6 gap-2" id="letters-grid">
                        <!-- Letters will be added here by JavaScript -->
                    </div>
                    
                    <div class="mt-4">
                        <button id="clear-letters" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded flex items-center justify-center">
                            <i class="fas fa-trash-alt mr-2"></i> Clear Letters
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Color theory explanation modal -->
        <div id="color-theory-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-md w-full max-h-[80vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold" id="color-theory-title">Color Theory</h3>
                    <button id="close-color-modal" class="text-gray-500 hover:text-gray-700">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="color-theory-content">
                    <!-- Content will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Canvas setup
            const mainCanvas = document.getElementById('main-canvas');
            const traceCanvas = document.getElementById('trace-canvas');
            const mainCtx = mainCanvas.getContext('2d');
            const traceCtx = traceCanvas.getContext('2d');
            
            // State variables
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            let currentColor = '#000000';
            let currentBrush = 'standard';
            let brushSize = 5;
            let brushOpacity = 1;
            let isMonochromatic = false;
            let isMandalaMode = false;
            let mandalaSymmetryPoints = 6;
            let mandalaColorMode = 'solid';
            let gradientStart = '#ff0000';
            let gradientEnd = '#0000ff';
            let isTraceLayerVisible = false;
            let currentLetterCase = 'upper';
            let currentLetterStyle = 'block';
            
            // Undo/redo functionality
            let undoStack = [];
            let redoStack = [];
            const MAX_UNDO_STEPS = 20;
            
            // Initialize canvas
            function initCanvas() {
                mainCanvas.width = mainCanvas.offsetWidth;
                mainCanvas.height = mainCanvas.offsetHeight;
                traceCanvas.width = traceCanvas.offsetWidth;
                traceCanvas.height = traceCanvas.offsetHeight;
                
                // White background by default
                mainCtx.fillStyle = 'white';
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                
                // Save initial state
                saveCanvasState();
                
                // Setup event listeners
                setupEventListeners();
                
                // Initialize color wheel
                initColorWheel();
                
                // Initialize letters
                initLetters();
                
                // Update UI
                updateBrushPreview();
                updateColorTheory(currentColor);
            }
            
            // Setup event listeners
            function setupEventListeners() {
                // Drawing events
                mainCanvas.addEventListener('mousedown', startDrawing);
                mainCanvas.addEventListener('mousemove', draw);
                mainCanvas.addEventListener('mouseup', stopDrawing);
                mainCanvas.addEventListener('mouseout', stopDrawing);
                
                // Touch events for mobile
                mainCanvas.addEventListener('touchstart', handleTouchStart);
                mainCanvas.addEventListener('touchmove', handleTouchMove);
                mainCanvas.addEventListener('touchend', handleTouchEnd);
                
                // Brush tools
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        currentBrush = this.id.replace('brush-', '');
                        updateBrushPreview();
                    });
                });
                
                // Brush size
                const brushSizeInput = document.getElementById('brush-size');
                brushSizeInput.addEventListener('input', function() {
                    brushSize = parseInt(this.value);
                    document.getElementById('brush-size-value').textContent = brushSize;
                    updateBrushPreview();
                });
                
                // Brush opacity
                const brushOpacityInput = document.getElementById('brush-opacity');
                brushOpacityInput.addEventListener('input', function() {
                    brushOpacity = parseFloat(this.value);
                    document.getElementById('brush-opacity-value').textContent = Math.round(brushOpacity * 100);
                    updateBrushPreview();
                });
                
                // Color wheel
                const colorWheel = document.getElementById('color-wheel');
                colorWheel.addEventListener('click', handleColorWheelClick);
                
                // Hex color input
                document.getElementById('apply-hex').addEventListener('click', applyHexColor);
                document.getElementById('color-hex').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') applyHexColor();
                });
                
                // Monochromatic toggle
                document.getElementById('monochromatic-toggle').addEventListener('change', function() {
                    isMonochromatic = this.checked;

                    if (isMonochromatic) {
                        // When entering monochromatic mode, use the current color's hue
                        const hsl = hexToHsl(currentColor);
                        baseHsl = { h: hsl.h, s: 100, l: 50 }; // Store the base hue at full saturation

                        // Update the wheel to show monochromatic shades
                        updateColorWheelForMonochromatic(hsl.h);

                        // Set current color to middle lightness
                        currentColor = hslToHex(hsl.h, 100, 50);
                    } else {
                        // Regular color wheel
                        document.getElementById('color-wheel').style.background =
                            'conic-gradient(red, yellow, lime, cyan, blue, magenta, red)';

                        // Restore the base color
                        if (baseHsl) {
                            currentColor = hslToHex(baseHsl.h, baseHsl.s, baseHsl.l);
                        }
                    }

                    updateCurrentColor(currentColor);
                    updateColorTheory(currentColor);
                });
                
                // Background selection
                document.querySelectorAll('[data-bg]').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const bg = this.getAttribute('data-bg');
                        setBackground(bg);
                    });
                });
                
                // Custom background upload
                document.getElementById('custom-bg').addEventListener('click', function() {
                    document.getElementById('bg-upload').click();
                });
                
                document.getElementById('bg-upload').addEventListener('change', function(e) {
                    if (e.target.files && e.target.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const img = new Image();
                            img.onload = function() {
                                mainCtx.drawImage(img, 0, 0, mainCanvas.width, mainCanvas.height);
                                saveCanvasState();
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(e.target.files[0]);
                    }
                });
                
                // Clear canvas
                document.getElementById('clear-canvas').addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear the canvas?')) {
                        mainCtx.fillStyle = 'white';
                        mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                        saveCanvasState();
                    }
                });
                
                // Save image
                document.getElementById('save-image').addEventListener('click', function() {
                    const link = document.createElement('a');
                    link.download = 'graffiti-art.png';
                    link.href = mainCanvas.toDataURL('image/png');
                    link.click();
                });
                
                // Undo/redo
                document.getElementById('undo').addEventListener('click', undo);
                document.getElementById('redo').addEventListener('click', redo);
                
                // Trace layer toggle
                document.getElementById('toggle-trace-layer').addEventListener('click', function() {
                    isTraceLayerVisible = !isTraceLayerVisible;
                    traceCanvas.style.display = isTraceLayerVisible ? 'block' : 'none';
                    this.classList.toggle('bg-blue-500', isTraceLayerVisible);
                    this.classList.toggle('bg-gray-500', !isTraceLayerVisible);
                });
                
                // Mandala mode toggle
                document.getElementById('toggle-mandala').addEventListener('click', function() {
                    isMandalaMode = !isMandalaMode;
                    document.getElementById('mandala-settings').style.display = isMandalaMode ? 'block' : 'none';
                    document.getElementById('symmetry-lines').style.display = isMandalaMode ? 'block' : 'none';
                    this.classList.toggle('bg-purple-500', isMandalaMode);
                    this.classList.toggle('bg-gray-500', !isMandalaMode);
                    
                    if (isMandalaMode) {
                        updateSymmetryLines();
                    }
                });
                
                // Mandala symmetry points
                document.getElementById('symmetry-points').addEventListener('input', function() {
                    mandalaSymmetryPoints = parseInt(this.value);
                    document.getElementById('symmetry-points-value').textContent = mandalaSymmetryPoints;
                    updateSymmetryLines();
                });
                
                // Mandala color mode
                document.getElementById('mandala-solid').addEventListener('click', function() {
                    mandalaColorMode = 'solid';
                    document.getElementById('mandala-solid').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('mandala-solid').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-gradient').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-gradient').classList.remove('bg-blue-500', 'text-white');
                    document.getElementById('gradient-colors').style.display = 'none';
                });
                
                document.getElementById('mandala-gradient').addEventListener('click', function() {
                    mandalaColorMode = 'gradient';
                    document.getElementById('mandala-gradient').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('mandala-gradient').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-solid').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('mandala-solid').classList.remove('bg-blue-500', 'text-white');
                    document.getElementById('gradient-colors').style.display = 'block';
                });
                
                // Gradient colors
                document.getElementById('gradient-start').addEventListener('input', function() {
                    gradientStart = this.value;
                });
                
                document.getElementById('gradient-end').addEventListener('input', function() {
                    gradientEnd = this.value;
                });
                
                // Letter case
                document.getElementById('upper-case').addEventListener('click', function() {
                    currentLetterCase = 'upper';
                    document.getElementById('upper-case').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('upper-case').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('lower-case').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('lower-case').classList.remove('bg-blue-500', 'text-white');
                    initLetters();
                });
                
                document.getElementById('lower-case').addEventListener('click', function() {
                    currentLetterCase = 'lower';
                    document.getElementById('lower-case').classList.add('bg-blue-500', 'text-white');
                    document.getElementById('lower-case').classList.remove('bg-gray-200', 'text-gray-800');
                    document.getElementById('upper-case').classList.add('bg-gray-200', 'text-gray-800');
                    document.getElementById('upper-case').classList.remove('bg-blue-500', 'text-white');
                    initLetters();
                });
                
                // Letter style
                document.getElementById('letter-style').addEventListener('change', function() {
                    currentLetterStyle = this.value;
                    initLetters();
                });
                
                // Clear letters
                document.getElementById('clear-letters').addEventListener('click', function() {
                    traceCtx.clearRect(0, 0, traceCanvas.width, traceCanvas.height);
                });
                
                // Color theory info
                document.querySelectorAll('.color-theory-box').forEach(box => {
                    box.addEventListener('click', function() {
                        const type = this.id;
                        showColorTheoryInfo(type);
                    });
                });
                
                // Close color theory modal
                document.getElementById('close-color-modal').addEventListener('click', function() {
                    document.getElementById('color-theory-modal').classList.add('hidden');
                });
            }
            
            // Drawing functions
            function startDrawing(e) {
                isDrawing = true;
                const pos = getPosition(e);
                [lastX, lastY] = [pos.x, pos.y];
                
                // For spray can, we want to start spraying immediately
                if (currentBrush === 'spray') {
                    draw(e);
                }
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const pos = getPosition(e);
                const x = pos.x;
                const y = pos.y;
                
                mainCtx.globalAlpha = brushOpacity;
                
                if (isMandalaMode) {
                    drawWithSymmetry(x, y);
                } else {
                    drawLine(lastX, lastY, x, y);
                }
                
                [lastX, lastY] = [x, y];
                
                // For spray can, we don't connect the dots
                if (currentBrush === 'spray') {
                    lastX = x;
                    lastY = y;
                }
            }
            
            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    saveCanvasState();
                }
            }
            
            function drawLine(x1, y1, x2, y2) {
                mainCtx.beginPath();
                mainCtx.moveTo(x1, y1);
                mainCtx.lineTo(x2, y2);
                
                switch (currentBrush) {
                    case 'standard':
                        mainCtx.lineCap = 'round';
                        mainCtx.lineJoin = 'round';
                        mainCtx.lineWidth = brushSize;
                        mainCtx.strokeStyle = currentColor;
                        mainCtx.stroke();
                        break;
                        
                    case 'calligraphy':
                        mainCtx.lineWidth = brushSize;
                        mainCtx.strokeStyle = currentColor;
                        
                        // Simulate calligraphy by varying line width based on angle
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const lineWidth = brushSize * (0.5 + 0.5 * Math.abs(Math.sin(angle)));
                        
                        mainCtx.lineWidth = lineWidth;
                        mainCtx.stroke();
                        break;
                        
                    case 'spray':
                        // Spray paint effect - draw random dots in a circular area
                        const density = brushSize * 2;
                        const radius = brushSize * 2;
                        
                        for (let i = 0; i < density; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * radius;
                            const sprayX = x2 + Math.cos(angle) * dist;
                            const sprayY = y2 + Math.sin(angle) * dist;
                            
                            // Random opacity for spray effect
                            const sprayOpacity = brushOpacity * (0.3 + Math.random() * 0.7);
                            mainCtx.globalAlpha = sprayOpacity;
                            
                            mainCtx.fillStyle = currentColor;
                            mainCtx.beginPath();
                            mainCtx.arc(sprayX, sprayY, 1 + Math.random() * 2, 0, Math.PI * 2);
                            mainCtx.fill();
                        }
                        break;
                        
                    case 'marker':
                        // Marker effect - semi-transparent with soft edges
                        mainCtx.lineWidth = brushSize;
                        mainCtx.strokeStyle = currentColor;
                        
                        // Draw multiple lines with decreasing opacity for soft edge effect
                        const steps = 3;
                        for (let i = 0; i < steps; i++) {
                            const opacity = brushOpacity * (0.3 + 0.7 * (i / steps));
                            mainCtx.globalAlpha = opacity;
                            mainCtx.lineWidth = brushSize * (1 - i * 0.2);
                            mainCtx.stroke();
                        }
                        break;
                        
                    case 'eraser':
                        mainCtx.globalCompositeOperation = 'destination-out';
                        mainCtx.lineCap = 'round';
                        mainCtx.lineJoin = 'round';
                        mainCtx.lineWidth = brushSize;
                        mainCtx.stroke();
                        mainCtx.globalCompositeOperation = 'source-over';
                        break;
                }
                
                mainCtx.globalAlpha = 1;
            }
            
            function drawWithSymmetry(x, y) {
                const centerX = mainCanvas.width / 2;
                const centerY = mainCanvas.height / 2;
                const angleStep = (2 * Math.PI) / mandalaSymmetryPoints;
                
                for (let i = 0; i < mandalaSymmetryPoints; i++) {
                    const angle = i * angleStep;
                    
                    // Calculate mirrored positions
                    const dx = x - centerX;
                    const dy = y - centerY;
                    
                    const mirroredX = centerX + dx * Math.cos(angle) + dy * Math.sin(angle);
                    const mirroredY = centerY + -dx * Math.sin(angle) + dy * Math.cos(angle);
                    
                    // Calculate mirrored last positions
                    const lastDx = lastX - centerX;
                    const lastDy = lastY - centerY;
                    
                    const mirroredLastX = centerX + lastDx * Math.cos(angle) + lastDy * Math.sin(angle);
                    const mirroredLastY = centerY + -lastDx * Math.sin(angle) + lastDy * Math.cos(angle);
                    
                    // Set color based on mode
                    if (mandalaColorMode === 'gradient') {
                        // Interpolate between gradient colors based on angle
                        const t = i / mandalaSymmetryPoints;
                        currentColor = interpolateColor(gradientStart, gradientEnd, t);
                    }
                    
                    // Draw the mirrored line
                    drawLine(mirroredLastX, mirroredLastY, mirroredX, mirroredY);
                }
                
                // Reset color to original for non-mirrored drawing
                if (mandalaColorMode === 'gradient') {
                    currentColor = interpolateColor(gradientStart, gradientEnd, 0);
                }
            }
            
            function interpolateColor(color1, color2, factor) {
                if (factor === undefined) factor = 0.5;
                
                const r1 = parseInt(color1.substring(1, 3), 16);
                const g1 = parseInt(color1.substring(3, 5), 16);
                const b1 = parseInt(color1.substring(5, 7), 16);
                
                const r2 = parseInt(color2.substring(1, 3), 16);
                const g2 = parseInt(color2.substring(3, 5), 16);
                const b2 = parseInt(color2.substring(5, 7), 16);
                
                const r = Math.round(r1 + factor * (r2 - r1));
                const g = Math.round(g1 + factor * (g2 - g1));
                const b = Math.round(b1 + factor * (b2 - b1));
                
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }
            
            // Touch event handlers
            function handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                mainCanvas.dispatchEvent(mouseEvent);
            }
            
            function handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                mainCanvas.dispatchEvent(mouseEvent);
            }
            
            function handleTouchEnd(e) {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup');
                mainCanvas.dispatchEvent(mouseEvent);
            }
            
            // Get mouse position relative to canvas
            function getPosition(e) {
                const rect = mainCanvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
           // Color wheel functionality - UPDATED
           function initColorWheel() {
               updateCurrentColor(currentColor);
           }
          
           function handleColorWheelClick(e) {
               const rect = e.target.getBoundingClientRect();
               const x = e.clientX - rect.left;
               const y = e.clientY - rect.top;
              
               const centerX = rect.width / 2;
               const centerY = rect.height / 2;
              
               const dx = x - centerX;
               const dy = y - centerY;
               const distance = Math.sqrt(dx * dx + dy * dy);
              
               if (distance > centerX) return; // Clicked outside the wheel
              
               // Calculate angle (corrected to get proper hue)
               let angle = Math.atan2(dy, dx);
               angle = (angle + Math.PI * 2) % (Math.PI * 2); // Normalize to 0-2Ï€
              
               // Convert angle to hue (0-360)
               const hue = (angle * (180 / Math.PI) + 360) % 360;
              
               if (isMonochromatic) {
                   // In monochromatic mode, distance determines lightness (0-100%)
                   const lightness = (distance / centerX) * 100;
                   currentColor = hslToHex(hsl.h, hsl.s, lightness);
               } else {
                   // In normal mode, distance determines saturation (0-100%)
                   const saturation = (distance / centerX) * 100;
                   const lightness = 50; // Fixed lightness for color wheel
                   currentColor = hslToHex(hue, saturation, lightness);
               }
              
               updateCurrentColor(currentColor);
               updateColorTheory(currentColor);
           }
          
           function updateCurrentColor(color) {
               document.getElementById('current-color').style.backgroundColor = color;
               document.getElementById('color-hex').value = color;
              
               // Get HSL values for positioning indicator
               const hsl = hexToHsl(color);
              
               // Calculate position on wheel
               const angle = (hsl.h / 360) * 2 * Math.PI;
               const radius = isMonochromatic ?
                   (hsl.l / 100) * 100 : // For monochromatic, distance = lightness
                   (hsl.s / 100) * 100;  // For color wheel, distance = saturation
              
               const centerX = 100;
               const centerY = 100;
               const x = centerX + Math.cos(angle) * radius;
               const y = centerY + Math.sin(angle) * radius;
              
               const indicator = document.querySelector('.color-wheel div');
               indicator.style.left = `${x}px`;
               indicator.style.top = `${y}px`;
              
               // Store base HSL for monochromatic mode
               if (!isMonochromatic) {
                   baseHsl = hsl; // Store the base color when not in monochromatic mode
               }
           }
          
           // Update color theory display when toggling monochromatic mode
           document.getElementById('monochromatic-toggle').addEventListener('change', function() {
               isMonochromatic = this.checked;
              
               if (isMonochromatic) {
                   // When entering monochromatic mode, use the current color's hue
                   const hsl = hexToHsl(currentColor);
                   baseHsl = { h: hsl.h, s: 100, l: 50 }; // Store the base hue at full saturation
                  
                   // Update the wheel to show monochromatic shades
                   updateColorWheelForMonochromatic(hsl.h);
                  
                   // Set current color to middle lightness
                   currentColor = hslToHex(hsl.h, 100, 50);
               } else {
                   // Regular color wheel
                   document.getElementById('color-wheel').style.background = 'conic-gradient(red, yellow, lime, cyan, blue, magenta, red)';
                  
                   // Restore the base color
                   if (baseHsl) {
                       currentColor = hslToHex(baseHsl.h, baseHsl.s, baseHsl.l);
                   }
               }
              
               updateCurrentColor(currentColor);
               updateColorTheory(currentColor);
           });
          
           function updateColorWheelForMonochromatic(hue) {
               const colorWheel = document.getElementById('color-wheel');
               const steps = 10;
               let conicGradient = '';

               for (let i = 0; i < steps; i++) {
                   const lightness = (i / (steps - 1)) * 100;
                   const color = hslToHex(hue, 100, lightness);
                   const pos = (i / steps) * 100;
                   const nextPos = ((i + 1) / steps) * 100;

                   conicGradient += `${color} ${pos}%, ${color} ${nextPos}%`;
                   if (i < steps - 1) conicGradient += ', ';
               }

               colorWheel.style.background = `conic-gradient(${conicGradient})`;
           }
            
            function showColorTheoryInfo(type) {
                const modal = document.getElementById('color-theory-modal');
                const title = document.getElementById('color-theory-title');
                const content = document.getElementById('color-theory-content');
                
                modal.classList.remove('hidden');
                
                let info = '';
                
                switch (type) {
                    case 'complementary':
                        title.textContent = 'Complementary Colors';
                        info = `
                            <p class="mb-4">Complementary colors are pairs of colors which, when combined, cancel each other out. This means that when placed next to each other, they create the strongest contrast.</p>
                            <p>In color theory, complementary colors are opposite each other on the color wheel. For example, red and green are complementary colors.</p>
                        `;
                        break;
                        
                    case 'triadic1':
                    case 'triadic2':
                        title.textContent = 'Triadic Color Scheme';
                        info = `
                            <p class="mb-4">A triadic color scheme uses three colors that are evenly spaced around the color wheel.</p>
                            <p>Triadic color harmonies tend to be quite vibrant, even if you use pale or unsaturated versions of your hues. To use a triadic harmony successfully, the colors should be carefully balanced - let one color dominate and use the two others for accent.</p>
                        `;
                        break;
                        
                    case 'analogous1':
                    case 'analogous2':
                        title.textContent = 'Analogous Colors';
                        info = `
                            <p class="mb-4">Analogous colors are groups of three colors that are next to each other on the color wheel, sharing a common color, with one being the dominant color, which tends to be a primary or secondary color, and a tertiary.</p>
                            <p>Analogous color schemes are often found in nature and are harmonious and pleasing to the eye. They usually match well and create serene and comfortable designs.</p>
                        `;
                        break;
                        
                    case 'tetradic1':
                    case 'tetradic2':
                    case 'tetradic3':
                        title.textContent = 'Tetradic Color Scheme';
                        info = `
                            <p class="mb-4">A tetradic color scheme, also known as double-complementary, uses four colors arranged into two complementary pairs.</p>
                            <p>This rich color scheme offers plenty of possibilities for variation. Tetradic color schemes work best if you let one color be dominant, and use the others as accents. The more colors you have in your palette, the more difficult it is to balance.</p>
                        `;
                        break;
                }
                
                content.innerHTML = info;
            }
            
            // Brush preview
            function updateBrushPreview() {
                const preview = document.getElementById('brush-preview-line');
                preview.style.backgroundColor = currentColor;
                preview.style.width = `${brushSize}px`;
                preview.style.height = `${brushSize}px`;
                preview.style.borderRadius = currentBrush === 'spray' ? '50%' : '0';
                
                // Special preview for calligraphy brush
                if (currentBrush === 'calligraphy') {
                    preview.style.width = `${brushSize}px`;
                    preview.style.height = `${brushSize * 2}px`;
                    preview.style.borderRadius = '0';
                }
                
                // Special preview for marker
                if (currentBrush === 'marker') {
                    preview.style.width = `${brushSize}px`;
                    preview.style.height = `${brushSize}px`;
                    preview.style.borderRadius = '0';
                    preview.style.opacity = '0.7';
                }
                
                // Special preview for spray
                if (currentBrush === 'spray') {
                    preview.style.width = `${brushSize * 2}px`;
                    preview.style.height = `${brushSize * 2}px`;
                    preview.style.borderRadius = '50%';
                }
            }
            
            // Background functions
            function setBackground(bg) {
                switch (bg) {
                    case 'white':
                        mainCtx.fillStyle = 'white';
                        break;
                    case 'black':
                        mainCtx.fillStyle = 'black';
                        break;
                    case 'brick':
                        drawBrickBackground();
                        return;
                    case 'concrete':
                        drawConcreteBackground();
                        return;
                    case 'wood':
                        drawWoodBackground();
                        return;
                }
                
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                saveCanvasState();
            }
            
            function drawBrickBackground() {
                const brickWidth = 60;
                const brickHeight = 30;
                const mortar = 5;
                
                mainCtx.fillStyle = '#b22222';
                
                for (let y = 0; y < mainCanvas.height; y += brickHeight + mortar) {
                    // Offset every other row
                    const offset = (y / (brickHeight + mortar)) % 2 ? brickWidth / 2 : 0;
                    
                    for (let x = -offset; x < mainCanvas.width; x += brickWidth + mortar) {
                        mainCtx.fillRect(x, y, brickWidth, brickHeight);
                    }
                }
                
                // Add mortar lines
                mainCtx.fillStyle = '#8B8B7A';
                for (let y = 0; y < mainCanvas.height; y += brickHeight + mortar) {
                    mainCtx.fillRect(0, y + brickHeight, mainCanvas.width, mortar);
                }
                
                // Vertical mortar lines (offset every other row)
                for (let y = 0; y < mainCanvas.height; y += brickHeight + mortar) {
                    const offset = (y / (brickHeight + mortar)) % 2 ? brickWidth / 2 : 0;
                    
                    for (let x = offset; x < mainCanvas.width; x += brickWidth + mortar) {
                        mainCtx.fillRect(x, y, mortar, brickHeight);
                    }
                }
                
                saveCanvasState();
            }
            
            function drawConcreteBackground() {
                // Base concrete color
                mainCtx.fillStyle = '#7a7a7a';
                mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                
                // Add texture with random noise
                const imageData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Add slight random variation to each pixel
                    const variation = Math.floor(Math.random() * 20) - 10;
                    data[i] += variation;     // R
                    data[i + 1] += variation; // G
                    data[i + 2] += variation; // B
                }
                
                mainCtx.putImageData(imageData, 0, 0);
                
                // Add some cracks
                mainCtx.strokeStyle = '#5a5a5a';
                mainCtx.lineWidth = 1;
                
                for (let i = 0; i < 5; i++) {
                    const startX = Math.random() * mainCanvas.width;
                    const startY = Math.random() * mainCanvas.height;
                    const length = 50 + Math.random() * 100;
                    const angle = Math.random() * Math.PI * 2;
                    
                    mainCtx.beginPath();
                    mainCtx.moveTo(startX, startY);
                    
                    // Create jagged crack
                    let x = startX;
                    let y = startY;
                    const segments = 5 + Math.floor(Math.random() * 5);
                    
                    for (let s = 0; s < segments; s++) {
                        x += Math.cos(angle) * (length / segments) * (0.8 + Math.random() * 0.4);
                        y += Math.sin(angle) * (length / segments) * (0.8 + Math.random() * 0.4);
                        
                        // Random slight angle variation
                        const segmentAngle = angle + (Math.random() - 0.5) * 0.5;
                        x += Math.cos(segmentAngle) * (length / segments / 2);
                        y += Math.sin(segmentAngle) * (length / segments / 2);
                        
                        mainCtx.lineTo(x, y);
                    }
                    
                    mainCtx.stroke();
                }
                
                saveCanvasState();
            }
            
            function drawWoodBackground() {
                // Base wood color
                const baseColor = '#8B4513';
                const hsl = hexToHsl(baseColor);
                
                // Create wood grain effect
                for (let x = 0; x < mainCanvas.width; x++) {
                    // Vary the color slightly to create grain
                    const variation = Math.sin(x / 30) * 5;
                    const lightness = hsl.l + variation;
                    const color = hslToHex(hsl.h, hsl.s, lightness);
                    
                    mainCtx.fillStyle = color;
                    mainCtx.fillRect(x, 0, 1, mainCanvas.height);
                }
                
                // Add darker grain lines
                mainCtx.strokeStyle = '#5D2906';
                mainCtx.lineWidth = 1;
                
                for (let i = 0; i < 10; i++) {
                    const y = Math.random() * mainCanvas.height;
                    const wavyness = 2 + Math.random() * 3;
                    
                    mainCtx.beginPath();
                    mainCtx.moveTo(0, y);
                    
                    for (let x = 0; x < mainCanvas.width; x += 10) {
                        const nextY = y + Math.sin(x / 50) * wavyness;
                        mainCtx.lineTo(x, nextY);
                    }
                    
                    mainCtx.stroke();
                }
                
                // Add knots
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * mainCanvas.width;
                    const y = Math.random() * mainCanvas.height;
                    const size = 10 + Math.random() * 20;
                    
                    mainCtx.fillStyle = '#5D2906';
                    mainCtx.beginPath();
                    mainCtx.ellipse(x, y, size, size * 0.5, 0, 0, Math.PI * 2);
                    mainCtx.fill();
                    
                    // Add rings around the knot
                    mainCtx.strokeStyle = '#5D2906';
                    mainCtx.lineWidth = 1;
                    
                    for (let r = size + 5; r < size + 20; r += 3) {
                        mainCtx.beginPath();
                        mainCtx.ellipse(x, y, r, r * 0.5, 0, 0, Math.PI * 2);
                        mainCtx.stroke();
                    }
                }
                
                saveCanvasState();
            }
            
            // Mandala symmetry lines
            function updateSymmetryLines() {
                const container = document.getElementById('symmetry-lines');
                container.innerHTML = '';
                
                const centerX = mainCanvas.width / 2;
                const centerY = mainCanvas.height / 2;
                const angleStep = (2 * Math.PI) / mandalaSymmetryPoints;
                
                for (let i = 0; i < mandalaSymmetryPoints; i++) {
                    const line = document.createElement('div');
                    line.className = 'symmetry-line';
                    line.style.left = `${centerX}px`;
                    line.style.transform = `rotate(${i * angleStep}rad)`;
                    container.appendChild(line);
                }
            }
            
            // Traceable letters
            function initLetters() {
                const lettersGrid = document.getElementById('letters-grid');
                lettersGrid.innerHTML = '';
                
                const letters = currentLetterCase === 'upper' ? 
                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ' : 
                    'abcdefghijklmnopqrstuvwxyz';
                
                for (let letter of letters) {
                    const letterBtn = document.createElement('button');
                    letterBtn.className = 'w-8 h-8 rounded border flex items-center justify-center bg-gray-100 hover:bg-gray-200';
                    letterBtn.textContent = letter;
                    letterBtn.title = `Add ${letter} to trace layer`;
                    
                    // Apply different styles based on currentLetterStyle
                    switch (currentLetterStyle) {
                        case 'block':
                            letterBtn.style.fontFamily = 'Arial Black, sans-serif';
                            letterBtn.style.fontWeight = 'bold';
                            break;
                        case 'bubble':
                            letterBtn.style.fontFamily = 'Comic Sans MS, cursive';
                            letterBtn.style.fontWeight = 'bold';
                            break;
                        case 'wildstyle':
                            letterBtn.style.fontFamily = 'Impact, sans-serif';
                            letterBtn.style.fontWeight = 'bold';
                            letterBtn.style.transform = 'skewX(-10deg)';
                            break;
                        case 'tag':
                            letterBtn.style.fontFamily = 'Courier New, monospace';
                            letterBtn.style.fontWeight = 'bold';
                            break;
                    }
                    
                    letterBtn.addEventListener('click', function() {
                        addLetterToTraceLayer(letter);
                    });
                    
                    lettersGrid.appendChild(letterBtn);
                }
            }
            
            function addLetterToTraceLayer(letter) {
                // Prompt user for position and size
                const size = prompt('Enter letter size (10-100):', '40');
                if (!size || isNaN(size) || size < 10 || size > 100) {
                    alert('Please enter a valid size between 10 and 100');
                    return;
                }
                
                // Calculate position (center of canvas)
                const x = mainCanvas.width / 2 - parseInt(size) / 2;
                const y = mainCanvas.height / 2 - parseInt(size) / 2;
                
                // Draw letter on trace canvas
                traceCtx.font = `${size}px ${getFontForStyle(currentLetterStyle)}`;
                traceCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                traceCtx.textAlign = 'left';
                traceCtx.textBaseline = 'top';
                traceCtx.fillText(letter, x, y);
            }
            
            function getFontForStyle(style) {
                switch (style) {
                    case 'block': return 'Arial Black, sans-serif';
                    case 'bubble': return 'Comic Sans MS, cursive';
                    case 'wildstyle': return 'Impact, sans-serif';
                    case 'tag': return 'Courier New, monospace';
                    default: return 'Arial, sans-serif';
                }
            }
            
            // Undo/redo functionality
            function saveCanvasState() {
                const imageData = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
                undoStack.push(imageData);
                
                // Limit undo stack size
                if (undoStack.length > MAX_UNDO_STEPS) {
                    undoStack.shift();
                }
                
                // Clear redo stack when new action is performed
                redoStack = [];
                
                // Update UI
                document.getElementById('undo').disabled = undoStack.length <= 1;
                document.getElementById('redo').disabled = true;
            }
            
            function undo() {
                if (undoStack.length > 1) {
                    const currentState = undoStack.pop();
                    redoStack.push(currentState);
                    
                    const prevState = undoStack[undoStack.length - 1];
                    mainCtx.putImageData(prevState, 0, 0);
                    
                    document.getElementById('redo').disabled = false;
                    document.getElementById('undo').disabled = undoStack.length <= 1;
                }
            }
            
            function redo() {
                if (redoStack.length > 0) {
                    const nextState = redoStack.pop();
                    undoStack.push(nextState);
                    
                    mainCtx.putImageData(nextState, 0, 0);
                    
                    document.getElementById('undo').disabled = false;
                    document.getElementById('redo').disabled = redoStack.length === 0;
                }
            }
            
            // Initialize the app
            initCanvas();
        });
    </script>
</body>
</html>

